<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-g">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CVRP Hybrid Solver</title>
    
    <!-- 1. Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Load Chart.js (Version 2.9.4) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.min.js"></script>
    
    <!-- 3. Load jsPDF (for PDF export) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <style>
        /* Custom font */
        body {
            font-family: 'Inter', sans-serif;
        }
        
        /* Simple spinner */
        .loader {
            border-top-color: #3498db;
            -webkit-animation: spin 1s linear infinite;
            animation: spin 1s linear infinite;
        }
        @-webkit-keyframes spin {
            0% { -webkit-transform: rotate(0deg); }
            100% { -webkit-transform: rotate(360deg); }
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Make tabs non-selectable */
        .tab-btn {
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10 and IE 11 */
            user-select: none; /* Standard syntax */
        }
    </style>
</head>
<body class="bg-gray-100 p-4 md:p-8">

    <div class="max-w-7xl mx-auto bg-white rounded-lg shadow-xl overflow-hidden">
        <header class="bg-gray-800 p-6">
            <h1 class="text-2xl font-bold text-white">Realistic CVRP Solver (Heterogeneous Fleet)</h1>
            <p class="text-gray-300">Based on the paper by Hern√°ndez-Aguilar et al. (2025)</p>
        </header>

        <div class="md:flex">
            <!-- === LEFT COLUMN (Controls) === -->
            <aside class="w-full md:w-1/3 p-6 border-r border-gray-200 divide-y divide-gray-200">
                
                <!-- Instructions -->
                <div class="pb-4">
                    <h2 class="text-xl font-semibold text-gray-700 mb-2">How to Use</h2>
                    <ol class="list-decimal list-inside text-sm text-gray-600 space-y-1">
                        <li>Add your **Depot** (Customer 1).</li>
                        <li>Add your **Fleet** (vehicles with different capacities).</li>
                        <li>Add all your **Customers** (X, Y, and Demand).</li>
                        <li>Set **Parameters** and click **Run Solver**.</li>
                    </ol>
                </div>
                
                <!-- Depot -->
                <div class="py-4">
                    <h2 class="text-lg font-semibold text-gray-700 mb-3">1. Add Depot</h2>
                    <div class="grid grid-cols-2 gap-2 mb-2">
                        <div>
                            <label for="depot-x" class="block text-sm font-medium text-gray-700">Depot X</label>
                            <input type="number" id="depot-x" value="50" class="mt-1 w-full p-2 border border-gray-300 rounded-md shadow-sm text-sm">
                        </div>
                        <div>
                            <label for="depot-y" class="block text-sm font-medium text-gray-700">Depot Y</label>
                            <input type="number" id="depot-y" value="50" class="mt-1 w-full p-2 border border-gray-300 rounded-md shadow-sm text-sm">
                        </div>
                    </div>
                </div>

                <!-- Fleet Management -->
                <div class="py-4">
                    <h2 class="text-lg font-semibold text-gray-700 mb-3">2. Add Fleet</h2>
                    <div class="flex items-center space-x-2 mb-3">
                        <input type="number" id="vehicle-capacity" placeholder="Vehicle Capacity" class="flex-grow p-2 border border-gray-300 rounded-md shadow-sm text-sm">
                        <button id="add-vehicle-btn" class="px-3 py-2 bg-blue-500 text-white rounded-md shadow-sm hover:bg-blue-600 text-sm font-medium">Add</button>
                    </div>
                    <ul id="vehicle-list" class="text-sm text-gray-700 space-y-1 max-h-24 overflow-y-auto">
                        <!-- Vehicles will be added here -->
                    </ul>
                </div>

                <!-- Customer Management -->
                <div class="py-4">
                    <h2 class="text-lg font-semibold text-gray-700 mb-3">3. Add Customers</h2>
                    <div class="grid grid-cols-3 gap-2 mb-2">
                        <input type="number" id="cust-x" placeholder="X" class="w-full p-2 border border-gray-300 rounded-md shadow-sm text-sm">
                        <input type="number" id="cust-y" placeholder="Y" class="w-full p-2 border border-gray-300 rounded-md shadow-sm text-sm">
                        <input type="number" id="cust-demand" placeholder="Demand" class="w-full p-2 border border-gray-300 rounded-md shadow-sm text-sm">
                    </div>
                    <button id="add-customer-btn" class="w-full mb-3 px-3 py-2 bg-blue-500 text-white rounded-md shadow-sm hover:bg-blue-600 text-sm font-medium">Add Customer</button>
                    <ul id="customer-list" class="text-sm text-gray-700 space-y-1 max-h-32 overflow-y-auto">
                        <!-- Customers will be added here -->
                    </ul>
                </div>

                <!-- Parameters -->
                <div class="pt-4">
                    <h2 class="text-lg font-semibold text-gray-700 mb-3">4. Parameters</h2>
                    <div class="mb-4">
                        <label for="iterations" class="block text-sm font-medium text-gray-700">Tabu Iterations</label>
                        <input type="number" id="iterations" value="200" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                    </div>
                    <div class="mb-6">
                        <label for="tenure" class="block text-sm font-medium text-gray-700">Tabu Tenure</label>
                        <input type="number" id="tenure" value="10" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
                    </div>

                    <!-- Run Button -->
                    <button id="run-solver" class="w-full flex items-center justify-center px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition disabled:opacity-50" disabled>
                        <svg id="run-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5 mr-2">
                            <path fill-rule="evenodd" d="M2 10a8 8 0 1116 0 8 8 0 01-16 0zm6.39-2.908a.75.75 0 01.766.027l3.5 2.25a.75.75 0 010 1.262l-3.5 2.25A.75.75 0 018 12.25v-4.5a.75.75 0 01.39-.658z" clip-rule="evenodd" />
                        </svg>
                        <div id="loader" class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-5 w-5 mr-2 hidden"></div>
                        <span id="run-text">Run Solver</span>
                    </button>
                </div>
            </aside>

            <!-- === RIGHT COLUMN (Results) === -->
            <main class="w-full md:w-2/3 p-6">
                <h2 class="text-xl font-semibold text-gray-700 mb-4">Results</h2>
                
                <!-- Tabs -->
                <div class="mb-4 border-b border-gray-200">
                    <nav class="-mb-px flex space-x-8" aria-label="Tabs">
                        <button id="tab-cost-plot" class="tab-btn border-blue-500 text-blue-600 whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm">Cost Plot</button>
                        <button id="tab-route-plot" class="tab-btn border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm">Route Plot</button>
                        <button id="tab-summary" class="tab-btn border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm">Solver Log</button>
                    </nav>
                </div>
                
                <!-- Alert Box -->
                <div id="alert-box" class="hidden p-4 mb-4 text-sm text-red-700 bg-red-100 rounded-lg" role="alert">
                    <span class="font-medium">Error!</span> <span id="alert-text"></span>
                </div>

                <!-- Cost Plot Tab Content -->
                <div id="content-cost-plot" class="tab-content">
                    <p id="cost-plot-placeholder" class="text-gray-500 text-center py-12">Add a fleet and customers, then run the solver to see the live cost plot.</p>
                    <canvas id="cost-chart"></canvas>
                </div>

                <!-- Route Plot Tab Content -->
                <div id="content-route-plot" class="tab-content hidden">
                    <p id="route-plot-placeholder" class="text-gray-500 text-center py-12">Solution routes will appear here after the solver finishes.</p>
                    <canvas id="solution-chart"></canvas>
                    <button id="download-pdf-btn" class="hidden mt-4 w-full flex items-center justify-center px-4 py-2 bg-gray-600 text-white font-semibold rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-75 transition">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5 mr-2">
                            <path d="M10.75 2.75a.75.75 0 00-1.5 0v8.614L6.295 8.23a.75.75 0 00-1.09 1.03l4.25 4.5a.75.75 0 001.09 0l4.25-4.5a.75.75 0 00-1.09-1.03l-2.955 3.134V2.75z" />
                            <path d="M3.5 12.75a.75.75 0 00-1.5 0v2.5A2.75 2.75 0 004.75 18h10.5A2.75 2.75 0 0018 15.25v-2.5a.75.75 0 00-1.5 0v2.5c0 .69-.56 1.25-1.25 1.25H4.75c-.69 0-1.25-.56-1.25-1.25v-2.5z" />
                        </svg>
                        Download Route Plot as PDF
                    </button>
                </div>

                <!-- Summary Tab Content -->
                <div id="content-summary" class="tab-content hidden">
                    <pre id="summary-text" class="text-sm bg-gray-900 text-white p-4 rounded-lg overflow-x-auto">Run the solver to see the cost summary.</pre>
                </div>
            </main>
        </div>
    </div>

    <!-- === JAVASCRIPT LOGIC === -->
    <script>
        // --- Global Variables ---
        let depot = null;
        let vehicles = []; // Stores { id: 1, capacity: 100 }
        let customers = []; // Stores Customer objects
        let customerCounter = 2; // Depot is 1
        
        let routeSolutionChart = null;
        let costChart = null;
        let datalabelPluginRegistered = false;

        // --- DOM Elements ---
        const runButton = document.getElementById('run-solver');
        const runText = document.getElementById('run-text');
        const runIcon = document.getElementById('run-icon');
        const loader = document.getElementById('loader');
        
        const iterInput = document.getElementById('iterations');
        const tenureInput = document.getElementById('tenure');
        
        const tabCostPlot = document.getElementById('tab-cost-plot');
        const tabRoutePlot = document.getElementById('tab-route-plot');
        const tabSummary = document.getElementById('tab-summary');
        
        const contentCostPlot = document.getElementById('content-cost-plot');
        const contentRoutePlot = document.getElementById('content-route-plot');
        const contentSummary = document.getElementById('content-summary');
        
        const costPlotPlaceholder = document.getElementById('cost-plot-placeholder');
        const routePlotPlaceholder = document.getElementById('route-plot-placeholder');
        const summaryText = document.getElementById('summary-text');
        
        const alertBox = document.getElementById('alert-box');
        const alertText = document.getElementById('alert-text');
        
        const downloadPdfBtn = document.getElementById('download-pdf-btn');
        
        // New UI Elements
        const depotXInput = document.getElementById('depot-x');
        const depotYInput = document.getElementById('depot-y');
        
        const vehicleCapacityInput = document.getElementById('vehicle-capacity');
        const addVehicleBtn = document.getElementById('add-vehicle-btn');
        const vehicleList = document.getElementById('vehicle-list');
        
        const custXInput = document.getElementById('cust-x');
        const custYInput = document.getElementById('cust-y');
        const custDemandInput = document.getElementById('cust-demand');
        const addCustomerBtn = document.getElementById('add-customer-btn');
        const customerList = document.getElementById('customer-list');
        
        // --- Input Validation ---
        function checkRunButtonStatus() {
            if (vehicles.length > 0 && customers.length > 0) {
                runButton.disabled = false;
            } else {
                runButton.disabled = true;
            }
        }

        // --- Fleet Management Logic ---
        addVehicleBtn.addEventListener('click', () => {
            const capacity = parseInt(vehicleCapacityInput.value);
            if (capacity > 0) {
                const vehicleId = vehicles.length + 1;
                vehicles.push({ id: vehicleId, capacity: capacity });
                
                const li = document.createElement('li');
                li.textContent = `Vehicle ${vehicleId} (Capacity: ${capacity})`;
                vehicleList.appendChild(li);
                
                vehicleCapacityInput.value = '';
                checkRunButtonStatus();
                hideAlert();
            } else {
                showError("Please enter a valid vehicle capacity.");
            }
        });
        
        // --- Customer Management Logic ---
        addCustomerBtn.addEventListener('click', () => {
            const x = parseFloat(custXInput.value);
            const y = parseFloat(custYInput.value);
            const demand = parseInt(custDemandInput.value);
            
            if (demand > 0 && !isNaN(x) && !isNaN(y)) {
                const cust = new Customer(customerCounter, x, y, demand);
                customers.push(cust);
                
                const li = document.createElement('li');
                li.textContent = `C${cust.id}: (${x}, ${y}) - Demand: ${demand}`;
                customerList.appendChild(li);
                
                customerCounter++;
                custXInput.value = '';
                custYInput.value = '';
                custDemandInput.value = '';
                checkRunButtonStatus();
                hideAlert();
            } else {
                showError("Please enter valid X, Y, and Demand for the customer.");
            }
        });


        // --- Tab Switching Logic ---
        function showTab(tabName) {
            const tabs = [tabCostPlot, tabRoutePlot, tabSummary];
            const contents = [contentCostPlot, contentRoutePlot, contentSummary];
            
            tabs.forEach((tab, index) => {
                const content = contents[index];
                if (tab.id === `tab-${tabName}`) {
                    content.classList.remove('hidden');
                    tab.classList.add('border-blue-500', 'text-blue-600');
                    tab.classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
                } else {
                    content.classList.add('hidden');
                    tab.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
                    tab.classList.remove('border-blue-500', 'text-blue-600');
                }
            });
        }
        tabCostPlot.addEventListener('click', () => showTab('cost-plot'));
        tabRoutePlot.addEventListener('click', () => showTab('route-plot'));
        tabSummary.addEventListener('click', () => showTab('summary'));

        // --- Alert Logic ---
        function showError(message) {
            alertText.textContent = message;
            alertBox.classList.remove('hidden');
        }
        function hideAlert() {
            alertBox.classList.add('hidden');
        }
        
        // --- UI State Logic ---
        function setSolverState(isRunning) {
            if (isRunning) {
                runButton.disabled = true;
                runText.textContent = 'Running...';
                runIcon.classList.add('hidden');
                loader.classList.remove('hidden');
                summaryText.textContent = 'Solver is running. Please wait...';
                routePlotPlaceholder.textContent = 'Generating solution...';
                costPlotPlaceholder.textContent = 'Generating cost plot...';
                
                downloadPdfBtn.classList.add('hidden');
                
                if (routeSolutionChart) {
                    routeSolutionChart.destroy();
                }
                if (costChart) {
                    costChart.destroy();
                }
                showTab('cost-plot');
            } else {
                runButton.disabled = false;
                runText.textContent = 'Run Solver';
                runIcon.classList.remove('hidden');
                loader.classList.add('hidden');
            }
        }
        
        // --- Cost Chart Logic ---
        function initializeCostChart() {
            costPlotPlaceholder.classList.add('hidden');
            const canvas = document.getElementById('cost-chart');
            const ctx = canvas.getContext('2d');
            
            if (costChart) {
                costChart.destroy();
            }

            costChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Current Cost',
                            data: [],
                            borderColor: 'rgba(54, 162, 235, 0.8)', // Blue
                            backgroundColor: 'transparent', // No fill
                            borderWidth: 1.5,
                            borderDash: [5, 5], // Dashed line
                            tension: 0.1
                        },
                        {
                            label: 'Best Cost',
                            data: [],
                            borderColor: 'rgba(239, 68, 68, 1)', // Red
                            backgroundColor: 'rgba(239, 68, 68, 0.1)', // Lighter red fill
                            borderWidth: 2.5, // Thicker line
                            steppedLine: 'before'
                        }
                    ]
                },
                options: {
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: 'Algorithm Step / Iteration'
                            }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: 'Total Cost (Distance)'
                            }
                        }]
                    },
                    animation: {
                        duration: 0 // Disable animation for live updates
                    }
                }
            });
        }
        
        function logCostUpdate(label, currentCost, bestCost) {
            return new Promise(resolve => {
                costChart.data.labels.push(label);
                costChart.data.datasets[0].data.push(currentCost);
                costChart.data.datasets[1].data.push(bestCost);
                
                const maxPoints = 500;
                if(costChart.data.labels.length > maxPoints) {
                    costChart.data.labels.shift();
                    costChart.data.datasets[0].data.shift();
                    costChart.data.datasets[1].data.shift();
                }
                
                costChart.update();
                setTimeout(resolve, 0); // Yield to event loop
            });
        }

        // --- Run Solver Logic ---
        runButton.addEventListener('click', async () => {
            if (vehicles.length === 0 || customers.length === 0) {
                showError("Please add at least one vehicle and one customer.");
                return;
            }
            
            setSolverState(true);
            hideAlert();
            
            try {
                const iterations = parseInt(iterInput.value);
                const tenure = parseInt(tenureInput.value);
                
                const results = [];
                const log = (message) => results.push(message);
                
                initializeCostChart();

                // --- 1. Load Data ---
                log("Building problem from UI...");
                const { problemDepot, problemCustomers, vehicleCapacities, distanceMatrix } = buildProblemFromUI();
                log(`Loaded ${problemCustomers.length} customers, ${vehicleCapacities.length} vehicles with capacities: [${vehicleCapacities.join(', ')}].`);

                // --- 2. Create Initial Solution ---
                log("\nCreating initial solution...");
                const initialSolution = createInitialSolution(problemDepot, problemCustomers, vehicleCapacities);
                const initialCost = calculateSolutionCost(initialSolution, distanceMatrix);
                log(`Initial Cost: ${initialCost.toFixed(2)}`);
                await logCostUpdate('Initial', initialCost, initialCost);

                // --- 3. Run Local Search ---
                log("\nApplying Local Search (Swap)...");
                const { lsSolution, bestLsCost } = await localSearchBySwapping(initialSolution, vehicleCapacities, distanceMatrix, initialCost, logCostUpdate);
                log(`Local Search Cost: ${bestLsCost.toFixed(2)}`);
                
                // --- 4. Run Tabu Search ---
                log("\nApplying Tabu Search (Relocation)...");
                const { tsSolution, tsBestCost } = await simpleTabuSearch(lsSolution, vehicleCapacities, distanceMatrix, iterations, tenure, log, logCostUpdate, bestLsCost);
                log(`Tabu Search Complete. Final Best Cost: ${tsBestCost.toFixed(2)}`);

                // --- 5. Display Results ---
                log("\n--- COST SUMMARY ---");
                log(`Initial Cost:     ${initialCost.toFixed(2)}`);
                log(`Local Search Cost: ${bestLsCost.toFixed(2)}`);
                log(`Tabu Search Cost:  ${tsBestCost.toFixed(2)}`);
                log(`Total Improvement: ${(initialCost - tsBestCost).toFixed(2)}`);
                
                summaryText.textContent = results.join('\n');
                plotRouteSolution(tsSolution);
                
                showTab('route-plot');

            } catch (error) {
                console.error(error);
                showError(`An error occurred: ${error.message}`);
            } finally {
                setSolverState(false);
            }
        });
        
        // --- PDF Download Logic ---
        downloadPdfBtn.addEventListener('click', () => {
            if (routeSolutionChart) {
                try {
                    const { jsPDF } = window.jspdf; 
                    const pdf = new jsPDF('p', 'mm', 'a4');
                    
                    const canvas = document.getElementById('solution-chart');
                    const imgData = canvas.toDataURL('image/png');
                    
                    const imgProps = pdf.getImageProperties(imgData);
                    const pdfWidth = 190;
                    const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
                    
                    pdf.addImage(imgData, 'PNG', 10, 10, pdfWidth, pdfHeight);
                    
                    pdf.save("cvrp_solution_routes.pdf");
                    
                } catch (e) {
                    console.error('Error generating PDF:', e);
                    showError('Could not generate PDF. ' + e.message);
                }
            } else {
                showError('No route plot found to download.');
            }
        });


        // ==========================================================
        // === CVRP SOLVER LOGIC (MODIFIED FOR HETEROGENEOUS FLEET) ===
        // ==========================================================
        
        // --- 1. `utils.js` ---
        class Customer {
            constructor(id, x, y, demand) {
                this.id = parseInt(id);
                this.x = parseFloat(x);
                this.y = parseFloat(y);
                this.demand = parseInt(demand);
            }
        }
        
        function calculateDistance(cust1, cust2) {
            return Math.sqrt(Math.pow(cust1.x - cust2.x, 2) + Math.pow(cust1.y - cust2.y, 2));
        }

        function calculateRouteDemand(route) {
            return route.reduce((sum, customer) => sum + customer.demand, 0);
        }

        function calculateSolutionCost(solution, distanceMatrix) {
            let totalCost = 0;
            for (const route of solution) {
                for (let i = 0; i < route.length - 1; i++) {
                    const custA = route[i];
                    const custB = route[i+1];
                    totalCost += distanceMatrix[custA.id][custB.id];
                }
            }
            return totalCost;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // --- 2. `data_loader.js` (MODIFIED) ---
        function buildProblemFromUI() {
            // Get Depot
            const depotX = parseFloat(depotXInput.value);
            const depotY = parseFloat(depotYInput.value);
            if (isNaN(depotX) || isNaN(depotY)) {
                throw new Error("Invalid Depot coordinates.");
            }
            const problemDepot = new Customer(1, depotX, depotY, 0);
            
            // Get Customers (already stored in global `customers` array)
            const problemCustomers = [...customers];
            
            // Get Vehicle Capacities (from global `vehicles` array)
            const vehicleCapacities = vehicles.map(v => v.capacity);
            if (vehicleCapacities.length === 0) {
                throw new Error("No vehicles added to the fleet.");
            }
            
            // Create a combined list for the distance matrix
            const allNodes = [problemDepot, ...problemCustomers];
            
            // Build Distance Matrix
            const n = allNodes.length;
            const maxId = Math.max(...allNodes.map(c => c.id));
            const distanceMatrix = Array(maxId + 1).fill(null).map(() => Array(maxId + 1).fill(0));
            
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    const custA = allNodes[i];
                    const custB = allNodes[j];
                    distanceMatrix[custA.id][custB.id] = calculateDistance(custA, custB);
                }
            }
            
            return { problemDepot, problemCustomers, vehicleCapacities, distanceMatrix };
        }
        
        // --- 3. `initial_solution.js` (MODIFIED) ---
        function createInitialSolution(depot, customers, vehicleCapacities) {
            let solution = [];
            let unassignedCustomers = [...customers];
            const numVehicles = vehicleCapacities.length;
            
            while (unassignedCustomers.length > 0) {
                solution = [];
                unassignedCustomers = [...customers];
                shuffleArray(unassignedCustomers);
                
                for (let i = 0; i < numVehicles; i++) {
                    let tour = [depot];
                    let currentDemand = 0;
                    const vehicleCapacity = vehicleCapacities[i]; // Use specific capacity
                    
                    let customersToRemove = [];
                    for (const customer of unassignedCustomers) {
                        if (currentDemand + customer.demand <= vehicleCapacity) {
                            tour.push(customer);
                            currentDemand += customer.demand;
                            customersToRemove.push(customer);
                        }
                    }
                    
                    unassignedCustomers = unassignedCustomers.filter(c => !customersToRemove.includes(c));
                    tour.push(depot);
                    solution.push(tour);
                }
                
                if (unassignedCustomers.length > 0) {
                    // This could happen if capacities are too small
                    // For this app, we'll just try again. A more robust
                    // solver might have a better construction heuristic.
                    console.warn("Failed to assign all customers. Retrying...");
                }
            }
            return solution;
        }

        // --- 4. `local_search.js` (MODIFIED) ---
        async function localSearchBySwapping(solution, vehicleCapacities, distMatrix, initialCost, logCostUpdate) {
            let improved = true;
            let currentSolution = JSON.parse(JSON.stringify(solution));
            let bestLsCost = initialCost;
            let lsIter = 0;

            while (improved) {
                improved = false;
                
                for (let r1Idx = 0; r1Idx < currentSolution.length; r1Idx++) {
                    for (let c1Idx = 1; c1Idx < currentSolution[r1Idx].length - 1; c1Idx++) {
                        for (let r2Idx = r1Idx; r2Idx < currentSolution.length; r2Idx++) {
                            
                            let startC2Idx = (r1Idx === r2Idx) ? c1Idx + 1 : 1;
                            
                            for (let c2Idx = startC2Idx; c2Idx < currentSolution[r2Idx].length - 1; c2Idx++) {
                                const route1 = currentSolution[r1Idx];
                                const route2 = currentSolution[r2Idx];
                                
                                const cust1 = route1[c1Idx];
                                const cust2 = route2[c2Idx];
                                
                                // MODIFIED: Check heterogeneous capacity
                                if (r1Idx !== r2Idx) {
                                    const r1NewDemand = calculateRouteDemand(route1) - cust1.demand + cust2.demand;
                                    const r2NewDemand = calculateRouteDemand(route2) - cust2.demand + cust1.demand;
                                    
                                    // Check against specific capacity for each route
                                    if (r1NewDemand > vehicleCapacities[r1Idx] || r2NewDemand > vehicleCapacities[r2Idx]) {
                                        continue;
                                    }
                                }

                                // ... (Rest of the delta calculation is the same) ...
                                const c1Prev = route1[c1Idx - 1];
                                const c1Next = route1[c1Idx + 1];
                                const c2Prev = route2[c2Idx - 1];
                                const c2Next = route2[c2Idx + 1];
                                
                                let costRemoved = 0;
                                let costAdded = 0;
                                
                                if (r1Idx === r2Idx) {
                                    if (c1Idx + 1 === c2Idx) { // Adjacent
                                        costRemoved = distMatrix[c1Prev.id][cust1.id] + distMatrix[cust1.id][cust2.id] + distMatrix[cust2.id][c2Next.id];
                                        costAdded = distMatrix[c1Prev.id][cust2.id] + distMatrix[cust2.id][cust1.id] + distMatrix[cust1.id][c2Next.id];
                                    } else { // Non-adjacent
                                        costRemoved = distMatrix[c1Prev.id][cust1.id] + distMatrix[cust1.id][c1Next.id] +
                                                      distMatrix[c2Prev.id][cust2.id] + distMatrix[cust2.id][c2Next.id];
                                        costAdded = distMatrix[c1Prev.id][cust2.id] + distMatrix[cust2.id][c1Next.id] +
                                                    distMatrix[c2Prev.id][cust1.id] + distMatrix[cust1.id][c2Next.id];
                                    }
                                } else { // Inter-route
                                    costRemoved = distMatrix[c1Prev.id][cust1.id] + distMatrix[cust1.id][c1Next.id] +
                                                  distMatrix[c2Prev.id][cust2.id] + distMatrix[cust2.id][c2Next.id];
                                    costAdded = distMatrix[c1Prev.id][cust2.id] + distMatrix[cust2.id][c1Next.id] +
                                                distMatrix[c2Prev.id][cust1.id] + distMatrix[cust1.id][c2Next.id];
                                }
                                
                                const delta = costAdded - costRemoved;
                                
                                if (delta < -0.0001) {
                                    currentSolution[r1Idx][c1Idx] = cust2;
                                    currentSolution[r2Idx][c2Idx] = cust1;
                                    improved = true;
                                    lsIter++;
                                    
                                    bestLsCost = calculateSolutionCost(currentSolution, distMatrix);
                                    await logCostUpdate(`LS ${lsIter}`, bestLsCost, bestLsCost);
                                    
                                    break;
                                }
                            }
                            if (improved) break;
                        }
                        if (improved) break;
                    }
                    if (improved) break;
                }
            }
            return { lsSolution: currentSolution, bestLsCost: bestLsCost };
        }

        // --- 5. `tabu_search.js` (MODIFIED) ---
        async function simpleTabuSearch(solution, vehicleCapacities, distMatrix, iters, tabuTenure, log, logCostUpdate, initialBestCost) {
            let S_cur = JSON.parse(JSON.stringify(solution));
            let S_best = JSON.parse(JSON.stringify(solution));
            
            let currentCost = calculateSolutionCost(S_cur, distMatrix);
            let bestCost = initialBestCost;
            
            let tabuList = [];
            
            log(`Starting Tabu Search. Initial Cost: ${currentCost.toFixed(2)}`);

            for (let iterNum = 0; iterNum < iters; iterNum++) {
                
                let bestMove = null;
                let bestMoveDelta = Infinity;

                for (let r1Idx = 0; r1Idx < S_cur.length; r1Idx++) {
                    for (let cIdx = 1; cIdx < S_cur[r1Idx].length - 1; cIdx++) {
                        const customerToMove = S_cur[r1Idx][cIdx];
                        
                        for (let r2Idx = 0; r2Idx < S_cur.length; r2Idx++) {
                            for (let insertPos = 1; insertPos < S_cur[r2Idx].length; insertPos++) {
                                
                                if (r1Idx === r2Idx && (cIdx === insertPos || cIdx + 1 === insertPos)) {
                                    continue;
                                }
                                
                                // MODIFIED: Check heterogeneous capacity
                                if (r1Idx !== r2Idx) {
                                    // Check if route 2 can handle the new demand
                                    if (calculateRouteDemand(S_cur[r2Idx]) + customerToMove.demand > vehicleCapacities[r2Idx]) {
                                        continue;
                                    }
                                }

                                // ... (Rest of delta calculation is the same) ...
                                const cPrev = S_cur[r1Idx][cIdx - 1];
                                const cNext = S_cur[r1Idx][cIdx + 1];
                                const costRemoved = distMatrix[cPrev.id][customerToMove.id] + 
                                                  distMatrix[customerToMove.id][cNext.id] - 
                                                  distMatrix[cPrev.id][cNext.id];
                                
                                const insPrev = S_cur[r2Idx][insertPos - 1];
                                const insNext = S_cur[r2Idx][insertPos];
                                const costAdded = distMatrix[insPrev.id][customerToMove.id] + 
                                                distMatrix[customerToMove.id][insNext.id] - 
                                                distMatrix[insPrev.id][insNext.id];
                                
                                const delta = costAdded - costRemoved;
                                const isTabu = tabuList.includes(customerToMove.id);
                                const aspirationMet = currentCost + delta < bestCost;

                                if (aspirationMet) {
                                    if (delta < bestMoveDelta) {
                                        bestMove = { r1Idx, cIdx, r2Idx, insertPos, delta };
                                        bestMoveDelta = delta;
                                    }
                                } else if (!isTabu) {
                                    if (delta < bestMoveDelta) {
                                        bestMove = { r1Idx, cIdx, r2Idx, insertPos, delta };
                                        bestMoveDelta = delta;
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (bestMove) {
                    const { r1Idx, cIdx, r2Idx, insertPos, delta } = bestMove;
                    
                    const customerToMove = S_cur[r1Idx].splice(cIdx, 1)[0];
                    
                    if (r1Idx === r2Idx) {
                        if (cIdx < insertPos) {
                            S_cur[r2Idx].splice(insertPos - 1, 0, customerToMove);
                        } else {
                            S_cur[r2Idx].splice(insertPos, 0, customerToMove);
                        }
                    } else {
                        S_cur[r2Idx].splice(insertPos, 0, customerToMove);
                    }
                    
                    currentCost += delta;
                    
                    tabuList.push(customerToMove.id);
                    if (tabuList.length > tabuTenure) {
                        tabuList.shift();
                    }
                    
                    if (currentCost < bestCost) {
                        bestCost = currentCost;
                        S_best = JSON.parse(JSON.stringify(S_cur));
                        log(`  Iter ${iterNum}: New Best Cost = ${bestCost.toFixed(2)}`);
                    }
                }
                
                await logCostUpdate(`TS ${iterNum}`, currentCost, bestCost);
            }
            
            await logCostUpdate(`TS ${iters}`, currentCost, bestCost);
            
            return { tsSolution: S_best, tsBestCost: bestCost };
        }

        // --- 6. `visualizer.js` ---
        function plotRouteSolution(solution) {
            routePlotPlaceholder.classList.add('hidden');
            const canvas = document.getElementById('solution-chart');
            const ctx = canvas.getContext('2d');
            
            if (routeSolutionChart) {
                routeSolutionChart.destroy();
            }

            const datasets = [];
            const depot = solution[0][0];

            datasets.push({
                label: 'Depot',
                data: [{ x: depot.x, y: depot.y }],
                backgroundColor: 'black',
                pointStyle: 'rectRot',
                radius: 10,
            });

            solution.forEach((route, i) => {
                const color = `hsl(${(i * 360 / solution.length) % 360}, 70%, 50%)`;
                const routeData = route.map(cust => ({ x: cust.x, y: cust.y }));
                
                // ADDED: Add vehicle capacity to route label
                const capacity = vehicles[i] ? vehicles[i].capacity : 'N/A';
                
                datasets.push({
                    label: `Route ${i + 1} (Cap: ${capacity})`,
                    data: routeData,
                    borderColor: color,
                    backgroundColor: 'transparent',
                    showLine: true,
                    tension: 0.1,
                    pointRadius: 5,
                    pointBackgroundColor: color
                });

                route.forEach(cust => {
                    if (cust.id !== depot.id) {
                        datasets.push({
                            label: `Cust ${cust.id}`,
                            data: [{ x: cust.x, y: cust.y, id: cust.id, demand: cust.demand }], // Added demand
                            pointRadius: 0,
                            datalabels: {
                                formatter: (context) => context.data.id,
                                color: '#333',
                                anchor: 'bottom',
                                align: 'top',
                                font: { size: 10 }
                            }
                        });
                    }
                });
            });
            
            if (!datalabelPluginRegistered) {
                Chart.plugins.register({
                    id: 'datalabels',
                    afterDatasetsDraw: function(chart) {
                        const ctx = chart.ctx;
                        chart.data.datasets.forEach(function(dataset, i) {
                            if (dataset.datalabels) {
                                const meta = chart.getDatasetMeta(i);
                                meta.data.forEach(function(element, index) {
                                    const data = dataset.data[index];
                                    const label = data.id;
                                    
                                    ctx.fillStyle = dataset.datalabels.color || 'black';
                                    ctx.font = '10px sans-serif';
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'bottom';
                                    
                                    ctx.fillText(label, element.getCenterPoint().x, element.getCenterPoint().y - 8);
                                });
                            }
                        });
                    }
                });
                datalabelPluginRegistered = true;
            }

            routeSolutionChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: datasets
                },
                options: {
                    plugins: {
                        datalabels: {
                            display: false
                        }
                    },
                    legend: {
                        labels: {
                            filter: (item) => item.text && (item.text.includes('Route') || item.text.includes('Depot'))
                        }
                    },
                    tooltips: {
                        callbacks: {
                            label: function(tooltipItem, data) {
                                const dsLabel = data.datasets[tooltipItem.datasetIndex].label;
                                if (dsLabel.includes('Cust')) return null;
                                
                                // Find the customer object
                                const point = data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
                                const allNodes = [depot, ...customers];
                                const cust = allNodes.find(c => c.x === point.x && c.y === point.y);
                                
                                if (!cust) return dsLabel;
                                if (cust.id === depot.id) return "Depot";
                                
                                return `Cust ${cust.id} (Demand: ${cust.demand})`;
                            }
                        }
                    },
                    scales: {
                        xAxes: [{
                            type: 'linear',
                            position: 'bottom',
                            scaleLabel: {
                                display: true,
                                labelString: 'X Coordinate'
                            }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: 'Y Coordinate'
                            }
                        }]
                    }
                }
            });
            
            downloadPdfBtn.classList.remove('hidden');
        }
        
    </script>
</body>
</html>

